<!DOCTYPE html>
<meta charset="utf-8">
<script src="d3.v3.js"></script>
<script src="http://bnchdrff.github.io/d3.js/plugins/jsonp.js"></script>
<script src="dist/libs/jquery.js"></script>
<script src="dist/jstree.min.js"></script>
<script src="https://rawgithub.com/lodash/lodash/2.4.1/dist/lodash.min.js"></script>
<link rel="stylesheet" href="dist/themes/default/style.min.css" />
<style>

.link {
  fill:#666;
  stroke: #666;
  stroke-width: 1.5px;
}

.node circle {
  stroke: #fff;
  stroke-width: 1.5px;
}

text {
  font: 10px sans-serif;
  pointer-events: none;
}

#main
{
  width:100%;
}

#treeContainer
{
 display: inline;
 float:left;
 width:350px;
 margin-left: 20px;
 margin-top: 0;
}

#graphContainer
{
 display: inline;
 margin-top:0;
 padding-top:0;
 margin-left: 0;
}

#graph {
  display: inline;
}
</style>
  <body>
  <div id="main">
    <div id="treeContainer">
      <div id="treeview">
      </div><!--tree-->
    </div><!--treeContainer-->


    <div id="graphContainer">
      <div id="graph"></div> <!--graph-->
  
    </div> <!--graphContainer-->
  </div> <!--main-->

      <script>
d3.jsonp('http://chartercomplex-server.herokuapp.com/nodes.json?callback={callback}', function(got_some_nodes) {
  d3.jsonp('http://chartercomplex-server.herokuapp.com/edges.json?callback={callback}', function(got_some_edges) {
    window.data = {
      nodes: got_some_nodes.nodes,
      links: got_some_edges.edges
    };

    var nodeIds = _.pluck(data.nodes,'id');
    window.data.links.forEach(function(l){
      l.source = nodeIds.indexOf(l.source);
      l.target = nodeIds.indexOf(l.target);
    });

    tree(window.data);

    doEverything(window.data);

  });
});

function normalize_cat_name(name) {
  return name.trim().toLowerCase();
}

/**
 * Gets neighbors of a node, based on its edges.
 *
 * @todo degrees
 */
function get_neighbors(id, degree, edges) {
  return _.uniq(
    _.reduce(edges, function(memo, edge) {
      var source;
      var target;
      source = (edge.source.id) ? edge.source.id : edge.source;
      target = (edge.target.id) ? edge.target.id : edge.target;
      if (source == id) {
        memo.push(target);
      }
      if (target == id) {
        memo.push(source);
      }
      return memo;
    }, [])
  );
}

function addNeighborsToNodes(nodes, edges, degree) {
  var newnodes = _.map(nodes, function(node) {
    node.neighbors = get_neighbors(node.id, degree, edges);
    return node;
  });
  return newnodes;
}

function tree(data) {

  // build jstree data:
  var cat_names = _.uniq(_.map(_.pluck(data.nodes, 't'), function(name) {
    return normalize_cat_name(name);
  }));
  var categories = [];
  _.each(cat_names, function(category) {
    categories.push({
      "id" : normalize_cat_name(category),
      "parent" : "#",
      "text" : category
    });
  });

  _.each(data.nodes, function(node) {
    categories.push({
      'id': node.id,
      'parent': normalize_cat_name(node.t),
      'text': node.name
    });
  });

  $('#treeview').jstree({
    'core': {
      'data' : categories
    }
  });

  $('#treeview').on('select_node.jstree', function (e, jstree_node) {
    d3.selectAll(".node").style("fill", function(d) {
      if (d.name==jstree_node.node.text) {
        var context = this;
        return toggle_node(d, null, context);
      } else {
        return d.fillColor;
      }
    });
  });

  // $('#jstree_demo_div').on("changed.jstree", function (e, data) {
  //    console.log(data.selected);
  // });

}

function doEverything(data) {

  var width = 600,
      height = 500;

  var force = d3.layout.force()
      .nodes(d3.values(data.nodes))
      .links(data.links)
      .size([width, height])
      .linkDistance(100)
      .charge(-300)
      .on("tick", tick)
      .start();
    data.nodes = addNeighborsToNodes(data.nodes, data.links, 1);


  var svg = d3.select("#graph").append("svg")
      .attr("width", width)
      .attr("height", height);

  var link = svg.selectAll(".link")
      .data(force.links())
      .enter().append("line")
      .attr("class", "link");

  var labels = svg.selectAll('text')
      .data(data.links)
      .enter().append('text')
      .attr("x", function(d) { return (d.source.y + d.target.y) / 2; })
      .attr("y", function(d) { return (d.source.x + d.target.x) / 2; })
      .attr("text-anchor", "middle")
      .text(function(d) {return d.label;});

  var node = svg.selectAll(".node")
      .append('g').data(force.nodes());

  node.enter().append("g")
      .append("path")
      .attr("class", "node")
      .attr("d",  d3.svg.symbol().type(function(d)
        {
          var typeStr;
          if(d.t=="Organization")
          {
            typeStr="triangle-up";
          }
          else if(d.t=="Foundation")
          {
            typeStr= "circle";
          }
          else if(d.t=="Person")
          {
            typeStr= "square";
          }
          return typeStr;
        })
      )
      .style("fill", function (d) {
        var colorStr;
        if(d.t=="Organization")
        {
          colorStr='#FF0000';
        }
        else if(d.t=="Foundation")
        {
          colorStr= '#00FF00';
        }
        else if(d.t=="Person")
        {
          colorStr= '#0000FF';
        }
        d.fillColor = colorStr;
        d.toggled = false;
        return colorStr;
        })
      .on("mouseover", mouseover)
      .on("mouseout", mouseout)
      .on("click", toggle_node)
      .call(force.drag);

   node.append("text")
      .style("fill", "black")
      .attr("x", 12)
      .attr("dy", ".35em")
      .text(function(d) { return d.name; });

  function tick() {
    link
        .attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    node
        .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

    labels
        .attr("x", function(d) { return (d.source.x + d.target.x) / 2; })
        .attr("y", function(d) { return (d.source.y + d.target.y) / 2; });
  }

  function mouseover() {
    d3.select(this).transition()
        .duration(750)
        .attr('transform', 'scale(2)');
  }

  function mouseout() {
    d3.select(this).transition()
        .duration(750)
        .attr('transform', 'scale(1)');
  }

}

/**
 * Sets a certain node (data node and the corresponding d3 dom element)
 * as clicked or unclicked.
 *
 * Needs context `this` as current DOM element
 *
 * @param d
 *   d3 data object
 *
 * @param index
 *   d3 index, per its API (unused)
 *
 * @param context
 *   if u don't want the function to use `this`
 *
 * @return
 *   new color
 */
function toggle_node(d, index, context) {
  var thiiiiiis = (context ? context : this);
  d.toggled = !d.toggled;
  var toggleColor = (d.toggled ? d.fillColor : "yellow");
  d3.select(thiiiiiis).style("fill", toggleColor);

  highlight_neighbors(d.id, d.neighbors);

  return toggleColor;
}

function highlight_neighbors(center_node_id, neighbors) {
  d3.selectAll('.node').style('fill', function(d) {
    if (d.id !== center_node_id && !_.contains(neighbors, d.id)) {
      d.grayed_out == true;
      return 'gray';
    }
    return d.fillColor;
  });
}



      </script>
  </body>
</html>

